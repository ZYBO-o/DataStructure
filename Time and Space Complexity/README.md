# 时间与空间复杂度分析

<!-- GFM-TOC -->

* [时间与空间复杂度分析](#时间与空间复杂度分析)
  * [一、时间复杂度分析](#一时间复杂度分析)
  * [二、空间复杂度分析](#二空间复杂度分析)

<!-- GFM-TOC -->

---

`算法(Algorithm)`是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，比如排序就有前面的十大经典排序和几种奇葩排序，虽然结果相同，但在过程中消耗的资源和时间却会有很大的区别，比如快速排序与猴子排序）。

那么我们应该如何去衡量不同算法之间的优劣呢？

主要还是从算法所占用的「时间」和「空间」两个维度去考量。

- `时间维度`：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- `空间维度`：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。



## 一.时间复杂度分析

> 时间的流逝宛若寒冰的融化，散发着恐惧。——吴师兄这句话真的很有味道

### 1.大O符号表示法

`大O表示法`：算法的时间复杂度通常用大O符号表述，定义为 **T[n] = O(f(n)) **。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。

如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的`时间复杂度`。

> 上面公式中用到的 Landau符号是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。

大O符号是一种算法「复杂度」的「相对」「表示」方式。

这个句子里有一些重要而严谨的用词：

- 相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；
- 表示(representation)：大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；
- 复杂度(complexity)：如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。

### 2.常见的时间复杂度量级

我们先从常见的时间复杂度量级进行大O的理解：

- 常数阶O(1)
- 线性阶O(n)
- 平方阶O(n²)
- 对数阶O(logn)
- 线性对数阶O(nlogn)

<div align="center">  
  <img src="https://github.com/ZYBO-o/DataStructure/blob/main/images/13.png"  width="600"/> 
</div>

#### O(1)

无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1)

```c
void swapTwoInts(int &a, int &b){
 	int temp = a;
 	a = b;
	b = temp;
}
```

#### O(n)

在下面这段代码，for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用O(n)来表示它的时间复杂度。

```c
int sum ( int n ){
	int ret = 0;
	for ( int i = 0 ; i <= n ; i ++){
		ret += i;
	}
	return ret;
}
```

特别一提的是 c * O(n) 中的 c 可能小于 1 ，比如下面这段代码：

```c++
void reverse ( string &s ) {
	int n = s.size();
	for (int i = 0 ; i < n/2 ; i++){
		swap ( s[i] , s[n-1-i]);
}

```

#### O(n²)

当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。

```c++
void selectionSort(int arr[],int n){
	for(int i = 0; i < n ; i++){
		int minIndex = i;
		for (int j = i + 1; j < n ; j++ )
			if (arr[j] < arr[minIndex])
				minIndex = j;
		swap ( arr[i], arr[minIndex]);
}
```

这里简单的推导一下

- 当 i = 0 时，第二重循环需要运行 (n - 1) 次
- 当 i = 1 时，第二重循环需要运行 (n - 2) 次
- 。。。。。。

不难得到公式：

```matlab
(n - 1) + (n - 2) + (n - 3) + ... + 0
= (0 + n - 1) * n / 2
= O (n ^2)
```

#### O(logn)

![1](../images/12.gif)

```c++
int binarySearch( int arr[], int n , int target){
	int l = 0, r = n - 1;
	while ( l <= r) {
		int mid = l + (r - l) / 2;
		if (arr[mid] == target) 
      return mid;
		if (arr[mid] > target ) 
      r = mid - 1;
		else l = mid + 1;
	}
	return -1;
}
```

在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。

同样的还有下面两段代码也是 O(logn) 级别的时间复杂度。

```c++
// 整形转成字符串
string intToString ( int num ){
	string s = "";
	// n 经过几次“除以10”的操作后，等于0
	while (num ){
		s += '0' + num%10;
		num /= 10;
	}
	reverse(s)
	return s;
}
 
void hello (int n ) {
	// n 除以几次 2 到 1
	for ( int sz = 1; sz < n ; sz += sz) 
		for (int i = 1; i < n; i++)
			cout<< "Hello,五分钟学算法：）"<< endl;
}
```

#### O(nlogn)

将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。

```c++
void hello (){
	for( m = 1 ; m < n ; m++){
		i = 1;
		while( i < n ){
			i = i * 2;
		}
	}
}
```



### 3.不常见的时间复杂度

下面来分析一波另外几种复杂度： 递归算法的时间复杂度（recursive algorithm time complexity），最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均时间复杂度（average case time complexity）和均摊时间复杂度（amortized time complexity）。

#### 递归算法的时间复杂度

如果递归函数中，只进行一次递归调用，递归深度为depth；

在每个递归的函数中，时间复杂度为T；

**则总体的时间复杂度为O(T \* depth)**。

在前面的学习中，归并排序 与 快速排序 都带有递归的思想，并且时间复杂度都是O(nlogn) ，但并不是有递归的函数就一定是 O(nlogn) 级别的。从以下两种情况进行分析。





## 二.空间复杂度分析

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分：

(1) 固定部分，这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。

(2) 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。

一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))，其中n为问题的规模，S(n)表示空间复杂度。

**空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。**

以二叉查找树为例，举例说明二叉排序树的查找性能。

### 1.平衡二叉树

如果二叉树的是以红黑树等平衡二叉树实现的，则 n 个节点的二叉排序树的高度为 log2n+1 ，其查找效率为O(Log2n)，近似于折半查找。

<div align="center">  
  <img src="https://github.com/ZYBO-o/DataStructure/blob/main/images/i14.png"  width="600"/> 
</div>

### 2.列表二叉树

如果二叉树退变为列表了，则 n 个节点的高度或者说是长度变为了n，查找效率为O(n)，变成了顺序查找。

<div align="center">  
  <img src="https://github.com/ZYBO-o/DataStructure/blob/main/images/15.png"  width="600"/> 
</div>

### 3.一般二叉树

介于「列表二叉树」与「平衡二叉树」之间，查找性能也在O(Log2n)到O(n)之间。



---

参考博客：

+ [冰与火之歌：「时间」与「空间」复杂度——程序员吴师兄](https://blog.csdn.net/kexuanxiu1163/article/details/103080950)

